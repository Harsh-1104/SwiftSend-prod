IOS Unit 1 : After Class concept

Initializers in Swift are special methods used to create and initialize instances of a class, structure, or enumeration. They ensure that new instances are correctly set up before they are used. Initializers initialize stored properties and perform any other setup required by the instance.

### Initializer Syntax:

In Swift, initializers are defined using the `init` keyword.

```swift
class Person {
    var name: String
    
    // Initializer
    init(name: String) {
        self.name = name
    }
}
```

### Default Initializers:

Swift provides a default initializer for classes and structures that initialize all properties to their default values. If you don't provide any custom initializers, this default initializer is used.

```swift
class Person {
    var name: String
}

// Default initializer is provided by Swift
let person = Person()
```

### Custom Initializers:

You can define custom initializers to provide different initialization behavior or to accept additional parameters.

```swift
class Person {
    var name: String
    var age: Int
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
}
```

### Parameter Names and External Names:

You can specify external parameter names for initializer parameters to improve readability.

```swift
class Person {
    var name: String
    
    init(withName name: String) {
        self.name = name
    }
}

let person = Person(withName: "John")
```

### Optional Properties and Failable Initializers:

Initializers can also assign optional properties to `nil` or fail initialization entirely if necessary conditions aren't met.

```swift
class Person {
    var name: String?
    
    init?(name: String) {
        if name.isEmpty {
            return nil
        }
        self.name = name
    }
}

let person = Person(name: "John") // Successful initialization
let invalidPerson = Person(name: "") // Initialization fails, invalidPerson is nil
```

### Convenience Initializers:

Convenience initializers are secondary initializers that provide additional initialization options. They must call another designated initializer in the same class.

```swift
class Person {
    var name: String
    var age: Int
    
    init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
    
    convenience init(name: String) {
        self.init(name: name, age: 0) // Calls the designated initializer
    }
}

let person = Person(name: "John") // Uses the convenience initializer
```

### Required Initializers:

Required initializers ensure that all subclasses provide an implementation for a particular initializer.

```swift
class Vehicle {
    var wheels: Int
    
    required init(wheels: Int) {
        self.wheels = wheels
    }
}

class Car: Vehicle {
    var passengers: Int
    
    init(passengers: Int) {
        self.passengers = passengers
        super.init(wheels: 4)
    }
    
    required init(wheels: Int) {
        self.passengers = 0
        super.init(wheels: wheels)
    }
}
```

Initializers are essential for creating and initializing instances in Swift. They provide a mechanism for ensuring that instances are properly configured before use and allow for customization and flexibility in object initialization.

In Swift, `self` and `super` are special keywords used within classes and structures to refer to the current instance and its superclass, respectively.

### 1. `self` Keyword:

The `self` keyword refers to the current instance of a class or structure within its own methods, properties, and initializers. It allows you to access and modify properties, call methods, and reference other members of the same instance.

#### Usage:

```swift
class Person {
    var name: String
    
    init(name: String) {
        self.name = name // Referring to the name property of the current instance
    }
    
    func introduce() {
        print("Hello, my name is \(self.name)") // Using self to access the name property
    }
}
```

### 2. `super` Keyword:

The `super` keyword is used to access and call methods, properties, and initializers of the superclass from within a subclass. It allows subclasses to extend or override behavior defined in their superclass.

#### Usage:

```swift
class Vehicle {
    var wheels: Int
    
    init(wheels: Int) {
        self.wheels = wheels
    }
}

class Car: Vehicle {
    var passengers: Int
    
    init(passengers: Int) {
        self.passengers = passengers
        super.init(wheels: 4) // Calling the superclass initializer
    }
    
    func describe() {
        print("This car has \(self.passengers) passengers and \(super.wheels) wheels") // Using super to access superclass properties
    }
}
```

### Summary:

- `self`: Refers to the current instance of a class or structure within its own methods, properties, and initializers.
- `super`: Allows subclasses to access and call methods, properties, and initializers of their superclass, enabling inheritance and overriding behavior.

Using `self` and `super` keywords appropriately is crucial for working with object-oriented Swift code, as they provide mechanisms for accessing and manipulating instances and their superclass functionality.

Protocols and extensions are powerful features in Swift that allow you to define blueprints for methods, properties, and other requirements that types can adopt, and to extend the functionality of existing types without modifying their original implementation. Let's explore each of these concepts:

### Protocols:

Protocols define a set of methods, properties, and other requirements that a type can conform to. They provide a way to define a contract that types can adhere to, enabling polymorphic behavior and code reuse.

#### Declaration:

```swift
protocol Drawable {
    func draw()
    var color: String { get set }
}
```

#### Adoption:

```swift
class Circle: Drawable {
    var color: String = "Red"
    
    func draw() {
        print("Drawing a circle")
    }
}
```

#### Protocol Inheritance:

Protocols can inherit from other protocols, allowing you to build complex hierarchies of requirements.

```swift
protocol Shape: Drawable {
    var area: Double { get }
}
```

### Extensions:

Extensions allow you to add new functionality to existing types, including classes, structures, enums, and protocols. They enable you to extend the behavior of types without modifying their original implementation.

#### Adding Methods:

```swift
extension Int {
    func square() -> Int {
        return self * self
    }
}
```

#### Adding Properties:

```swift
extension Double {
    var squared: Double {
        return self * self
    }
}
```

#### Conformance to Protocols:

Extensions can be used to make existing types conform to protocols, enabling retroactive modeling.

```swift
extension Circle: Shape {
    var area: Double {
        return Double.pi * radius * radius
    }
}
```

#### Limitations:

Extensions cannot add stored properties or override existing functionality, and they cannot be used to conform to protocols that have associated type requirements.

### When to Use:

- **Protocols**: Use protocols to define a set of requirements that types can conform to, enabling polymorphism and code reuse.
- **Extensions**: Use extensions to add new functionality to existing types, including methods, properties, and conformance to protocols, without modifying their original implementation.

### Benefits:

- Protocols enable protocol-oriented programming, allowing you to define behavior in a flexible and reusable way.
- Extensions promote code organization and modularity by separating additional functionality from the original type definition.
- Both protocols and extensions facilitate code reuse and enable retroactive modeling, improving the flexibility and maintainability of your codebase.

Protocols and extensions are essential tools in Swift that enable you to build flexible, modular, and reusable code. Understanding how and when to use them can greatly enhance your ability to write clean, expressive, and maintainable code.

In iOS development, the Information Property List (Info.plist) file is a configuration file used to store essential metadata about your app and its environment. It contains key-value pairs that provide information such as the app's name, version, supported device orientations, permissions, and more. The Info.plist file is a critical component of every iOS app and is used by the system to configure the behavior of your app.

### Key Sections in Info.plist:

1. **General Information**:
   - `CFBundleName`: The human-readable name of the app.
   - `CFBundleIdentifier`: The unique identifier of the app (bundle ID).
   - `CFBundleVersion`: The build version number of the app.
   - `CFBundleShortVersionString`: The marketing version number of the app.
   - `CFBundleDisplayName`: The display name of the app shown on the device's home screen.

2. **App Permissions**:
   - `NSCameraUsageDescription`: Description of why the app requires access to the camera.
   - `NSPhotoLibraryUsageDescription`: Description of why the app requires access to the photo library.
   - `NSLocationWhenInUseUsageDescription`: Description of why the app requires access to the user's location while in use.
   - `NSMicrophoneUsageDescription`: Description of why the app requires access to the microphone.
   - `NSBluetoothPeripheralUsageDescription`: Description of why the app requires access to Bluetooth peripherals.
   - `NSContactsUsageDescription`: Description of why the app requires access to the user's contacts.

3. **App Capabilities**:
   - `UIBackgroundModes`: Specifies the app's supported background execution modes, such as audio, location updates, or background fetch.

4. **Device Requirements**:
   - `UISupportedInterfaceOrientations`: Specifies the device orientations supported by the app.
   - `UIRequiresFullScreen`: Specifies whether the app runs in full-screen mode.
   - `UIRequiresPersistentWiFi`: Specifies whether the app requires a Wi-Fi connection to function properly.

### App Permissions:

In iOS, apps need explicit permission from the user to access certain sensitive data or device features. These permissions are declared in the Info.plist file using specific keys, and the user is prompted to grant or deny these permissions when they are requested by the app.

#### Example:

```xml
<key>NSCameraUsageDescription</key>
<string>This app requires access to your camera to take photos and videos.</string>

<key>NSPhotoLibraryUsageDescription</key>
<string>This app requires access to your photo library to select and save photos.</string>

<key>NSLocationWhenInUseUsageDescription</key>
<string>This app requires access to your location while in use to provide location-based services.</string>
```

### Handling App Permissions:

When requesting permissions from the user, it's essential to provide clear and concise descriptions of why your app needs access to specific data or features. This helps build trust with the user and increases the likelihood of permission being granted.

### Summary:

The Info.plist file is a crucial part of every iOS app, containing essential metadata and configuration settings. App permissions declared in the Info.plist file help ensure that users understand why certain permissions are required and provide a mechanism for granting or denying access to sensitive data and device features.